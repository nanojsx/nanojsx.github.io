<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="theme-color" content="#ff4e6a" />
    <title>Nano JSX &bull; Lightweight 1kB JSX library</title>
    <meta
      name="description"
      content="Designed to build ultra fast Multi-Page Apps (MPAs), using isomorphic JavaScript. Written in TypeScript. Server Side first with partial hydration. Perfect for your next PWA. As small as svelte."
    />
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="stylesheet" href="/css/style.css?ver=0.0.7" />
    <link rel="prefetch" href="/docs.html" as="document" />
    <link rel="prefetch" href="/components.html" as="document" />
    <link rel="prefetch" href="/examples.html" as="document" />
  </head>
  <body>
    <div id="root">
      <header>
        <div class="is-center">
          <img id="logo" width="603" height="228" src="/img/logo-compressed.svg" alt="nano jsx logo" />
        </div>
        <h2 id="subtitle" class="is-center">Lightweight 1kB JSX library</h2>
        <p id="tags" class="is-center has-color-gray">TypeScript • Ultra Lightweight • SSR First</p>
        <div id="home-navigation" class="is-center">
          <ul>
            <li><a href="/docs.html">Docs</a></li>
            <li><a href="/components.html">Components</a></li>
            <li><a href="/examples.html">Examples</a></li>
            <li><a href="/ui.html">UI</a></li>
            <li>
              <a href="https://github.com/nanojsx/nano/discussions" target="_blank" rel="noopener">Discussions</a>
            </li>
          </ul>
        </div>
      </header>

      <section class="is-full-width">
        <div class="is-container-big">
          <div class="benefits">
            <div class="benefit">
              <h2 class="benefit-title">No Virtual Dom</h2>
              <p class="benefit-text">Just pure and fast JavaScript rendering.</p>
            </div>
            <div class="benefit">
              <h2 class="benefit-title">SSR First Approach</h2>
              <p class="benefit-text">Designed to be pre-rendered on the server.</p>
            </div>
            <div class="benefit">
              <h2 class="benefit-title">Partial Hydration</h2>
              <p class="benefit-text">Hydrates only the parts you really need.</p>
            </div>
            <div class="benefit">
              <h2 class="benefit-title">Ultra Lightweight</h2>
              <p class="benefit-text">Generates bundles as small as svelte.</p>
            </div>
            <div class="benefit">
              <h2 class="benefit-title">Node & Deno</h2>
              <p class="benefit-text">Server-side rendering on node and deno.</p>
            </div>
            <div class="benefit">
              <h2 class="benefit-title">Clean Code</h2>
              <p class="benefit-text">Nano JSX does not depend on any external libraries.</p>
            </div>
          </div>
        </div>
      </section>

      <section class="is-full-width has-background-light">
        <div class="is-container-big">
          <div class="code-example code-example-tabs">
            <div class="code-highlight">
              <div id="code-style-switcher" class="code-switcher">
                <p data-tab="counterJSX" id="show-jsx" class="is-active">JSX</p>
                <p data-tab="counterJavaScript" id="show-javascript">JavaScript</p>
                <p data-tab="counterTaggedTemplates" id="show-tagged-templates">Tagged Templates</p>
              </div>
              <pre
                class="has-no-border-radius-top-left has-no-margin-top"
              ><code id="counterJSX" class="language-tsx">loading...</code></pre>
              <pre
                class="has-no-border-radius-top-left has-no-margin-top is-hidden"
              ><code id="counterJavaScript" class="language-tsx">loading...</code></pre>
              <pre
                class="has-no-border-radius-top-left has-no-margin-top is-hidden"
              ><code id="counterTaggedTemplates" class="language-tsx ">loading...</code></pre>
            </div>

            <div class="code-result">
              <div id="counter-value">Counter: 0</div>
              <button id="button-increment">Increment</button>
              <button id="button-decrement">Decrement</button>

              <script>
                let counterValue = 0
                const valueElement = document.getElementById('counter-value')

                const setValue = newValue => {
                  counterValue += newValue
                  valueElement.innerHTML = `Counter: ${counterValue}`
                }
                const buttonI = document.getElementById('button-increment').addEventListener('click', () => setValue(1))
                const buttonD = document
                  .getElementById('button-decrement')
                  .addEventListener('click', () => setValue(-1))
              </script>
            </div>
          </div>
        </div>
      </section>

      <style>
        .code-switcher {
          background-color: #1a1d2a;
          border-radius: 8px 8px 0px 0px;
          display: inline-flex;
          margin-bottom: -1px;
        }
        .code-switcher p {
          font-size: 18px;
          cursor: pointer;
          color: white;
          padding: 16px 16px;
          margin: 0;
          border-radius: inherit;
        }
        .code-switcher p:hover {
          background-color: #0f111b;
        }
        .code-switcher p.is-active {
          background-color: #272a36;
        }
        /* mobile-only */
        @media only screen and (max-width: 420px) {
          .code-switcher p {
            font-size: 16px;
            padding: 12px 12px;
          }
        }
      </style>

      <script>
        ;(() => {
          const styleSwitcher = document.getElementById('code-style-switcher')
          const c = styleSwitcher.children
          for (i = 0; i < c.length; i++) {
            c[i].addEventListener('click', function () {
              const attr = this.getAttribute('data-tab')
              const tabs = ['counterJSX', 'counterJavaScript', 'counterTaggedTemplates']

              for (i = 0; i < c.length; i++) {
                c[i].classList.remove('is-active')
              }
              this.classList.add('is-active')

              tabs.forEach(t => {
                const tab = document.getElementById(t)
                if (tab.id === attr) tab.parentElement.classList.remove('is-hidden')
                else tab.parentElement.classList.add('is-hidden')
              })
            })
          }
        })()
      </script>

      <section>
        <h2 class="has-text-centered">What</h2>
        <p>
          Nano JSX is designed to build ultra fast MPAs and SPAs using JSX. It uses a different approach than other JSX
          libraries like React, Preact or Inferno.
        </p>
        <p>
          Nano JSX is really close to the DOM. There is no Virtual DOM and you can manipulate the DOM as you want. You
          can even call <code class="is-code">Nano.render()</code> inside a Component, which then renders some JSX code
          to manage another part of your app.
        </p>
        <p>
          You have full control over what the client and what the server renders. All Components are designed to work
          100% isomorphic.<br />For example, the api of the built-in Router Component works the same way Client-Side and
          Server-Side.
        </p>
        <p>
          Nano JSX is written in TypeScript. For Node.js it is exported to JavaScript (cjs) and for Deno I use
          denoify.land.
        </p>
        <h2 class="has-text-centered">Why<br /><small>(and how I do it)</small></h2>
        <p>
          In the past, I did a lot of websites/apps using Isomorphic React (Pre-Rendering on the Server and Hydrating on
          the client). Once the website did load all scripts, it was very fast (not so much on mobile though). But the
          scripts were always way too big.
        </p>
        <p>
          Nowadays, I prefer to Pre-Render the JSX on the server and only Hydrate the parts that are really needed. With
          Nano JSX, the client now only gets few kilobytes and uses much less CPU. I personally include inline styles to
          make the first paint as fast as possible (The styles I include are only for the current view). So, the client
          fetches only two necessary files index.html and bundle.js. The page is visually finished after loading the
          index.html file and then only fetches few kilobytes of JavaScript with the second request. Ultra fast first
          contentful paint (FCP) and no render blocking code.
        </p>
        <p>
          Instead of navigating to the next page with a client-side router (which is also possible), I prefetch the
          pages that the user will most likely navigate to next.
        </p>
        <p>
          For a huge app, I still use client-side React and Redux. But for everything else, like website, blog, online
          shop small to medium sized apps and even some mobile apps, I now use Nano JSX.
        </p>
        <p>
          Some of you might remember the old days of React when Class Components managed all states and functional
          Components did only render JSX Elements. That's the approach I like and use. I find it much more clear to read
          and write.
        </p>
        <h2 class="has-text-centered">Goal</h2>
        <p>
          The goal is to have a very small and very stable jsx library that can easily be included into any website.
          Just kind of like jQuery was at the time.
        </p>
      </section>

      <section class="is-full-width has-background-light">
        <div class="is-container">
          <h2 class="has-text-centered">Server Side Rendering</h2>
          <div class="code-example code-example-tabs">
            <div class="code-highlight">
              <div id="code-srr-switcher" class="code-switcher">
                <p data-tab="nodeSSR" id="show-node" class="is-active">Node</p>
                <p data-tab="denoSSR" id="show-deno">Deno</p>
              </div>
              <pre
                class="has-no-border-radius-top-left has-no-margin-top"
              ><code id="nodeSSR" class="language-tsx">loading...</code></pre>
              <pre
                class="has-no-border-radius-top-left has-no-margin-top is-hidden"
              ><code id="denoSSR" class="language-tsx ">loading...</code></pre>
            </div>
          </div>
        </div>
      </section>

      <script>
        ;(() => {
          const styleSwitcher = document.getElementById('code-srr-switcher')
          const c = styleSwitcher.children
          for (i = 0; i < c.length; i++) {
            c[i].addEventListener('click', function () {
              console.log('click')
              const attr = this.getAttribute('data-tab')
              const tabs = ['nodeSSR', 'denoSSR']

              for (i = 0; i < c.length; i++) {
                c[i].classList.remove('is-active')
              }
              this.classList.add('is-active')

              tabs.forEach(t => {
                const tab = document.getElementById(t)
                if (tab.id === attr) tab.parentElement.classList.remove('is-hidden')
                else tab.parentElement.classList.add('is-hidden')
              })
            })
          }
        })()
      </script>

      <section>
        <h2 class="has-text-centered">Partial Hydration</h2>
        <p>
          The library by it self is already small and fast, but in combination with its awesome capabilities, it becomes
          even faster.
        </p>
        <p>
          It's designed to be pre-rendered on the server and to then be partially hydrated on the client. The client
          will therefore have to download and render much less code.
        </p>
        <pre><code id="partialHydrationShowcase" class="language-tsx">loading...</code></pre>
        <h3 class="has-text-centered">Lazy Hydration</h3>
        <p>Not every component needs to be hydrated immediately. Lazy Hydration reduces First Input Delay (FID).</p>
        <pre><code id="hydrateLazy" class="language-tsx">loading...</code></pre>
      </section>

      <section class="is-full-width has-background-light">
        <div class="is-container">
          <h2 class="has-text-centered">Svelte vs Nano JSX</h2>
          <p>
            Although, the simple example below is 0.2kB bigger using nano JSX, once adding more features to your App
            like Event Handling, Component Lifecycle, Store or SVG support, the nano JSX application will generate a
            slightly smaller bundle size compared to Svelte.
          </p>
          <p>The same app with preact is 4.7kB, 8.6kB with inferno and 41.7kB with react.</p>
          <div class="code-example code-side-by-side">
            <div class="code-highlight">
              <pre class="has-no-margin-top"><code id="compareSvelte" class="language-tsx">loading...</code></pre>
            </div>
            <div class="code-highlight">
              <pre class="has-no-margin-top"><code id="compareNanoJSX" class="language-tsx">loading...</code></pre>
            </div>
          </div>

          <h2 class="has-text-centered">CustomElementsMode</h2>
          <p>
            You can define your components written with Nano JSX via `Nano.defineAsCustomElements` like svelte compiler.
            Nano JSX is ultra light UI library so web components made with Nano JSX is also light. You can make a light
            web components with the high developer experience, declarative UI and state management thanks to Nano JSX.
          </p>
          <div class="code-highlight">
            <pre class="has-no-margin-top"><code id="customElementsMode" class="language-tsx">loading...</code></pre>
          </div>
        </div>
      </section>

      <section>
        <h2 class="has-text-centered">Built-In Component</h2>
        <p>
          Nano JSX provides some useful Built-In Component, like Link, Img, Visible and Helmet and hopefully many many
          more in the future. All Built-In Components are as lightweight as possible and especially designed for Nano
          JSX.
        </p>
        <p>Visit <a href="/components.html">Components</a> to learn more.</p>
      </section>

      <section class="is-full-width">
        <div class="is-container-big">
          <h2 class="has-text-centered">Sandbox</h2>
          <p class="has-text-centered">
            Modify here or on
            <a href="https://codepen.io/yandeu/pen/MWKMmbq">codepen.io</a>.
          </p>
          <div class="codepen-wrapper" style="position: relative">
            <div class="spinner">
              <div class="double-bounce1"></div>
              <div class="double-bounce2"></div>
            </div>
            <p
              class="codepen"
              data-height="550"
              data-theme-id="39236"
              data-default-tab="js,result"
              data-user="yandeu"
              data-slug-hash="MWKMmbq"
              data-editable="true"
              data-pen-title="Nano JSX Sandbox"
            ></p>
          </div>
          <style>
            .cp_embed_wrapper {
              position: relative;
            }
            .codepen-wrapper {
              min-height: 550px;
              box-shadow: 4px 4px 20px 6px rgb(0 0 0 / 20%);
              border-radius: 6px;
            }
          </style>
        </div>
      </section>

      <section class="is-full-width has-background-light">
        <div class="is-container">
          <h2 class="has-text-centered">Project Template (node.js)</h2>
          <pre class="code-fit-width"><code id="projectTemplate" class="language-console">loading...</code></pre>
        </div>
        <div class="is-container">
          <h2 class="has-text-centered">Deno Example</h2>
          <p class="has-text-centered">
            Get
            <a href="https://github.com/nanojsx/nano-jsx-deno-example">nano-jsx-deno-example</a>
          </p>
        </div>
      </section>

      <footer class="is-full-width">
        <div class="is-container is-center">
          <div style="margin-bottom: 16px">
            <a style="color: black" href="https://github.com/nanojsx/nano">https://github.com/nanojsx/nano</a>
          </div>
          <div>
            <a
              class="github-button"
              href="https://github.com/yandeu"
              data-color-scheme="no-preference: dark; light: dark; dark: dark;"
              data-size="large"
              data-show-count="true"
              aria-label="Follow @yandeu on GitHub"
              >Follow @yandeu</a
            >
            <a
              class="github-button"
              href="https://github.com/nanojsx/nano"
              data-color-scheme="no-preference: dark; light: dark; dark: dark;"
              data-icon="octicon-star"
              data-size="large"
              data-show-count="true"
              aria-label="Star nanojsx/nano on GitHub"
              >Star</a
            >
            <a
              class="github-button"
              href="https://github.com/sponsors/yandeu"
              data-color-scheme="no-preference: dark; light: dark; dark: dark;"
              data-icon="octicon-heart"
              data-size="large"
              aria-label="Sponsor @yandeu on GitHub"
              >Sponsor</a
            >
            <a
              href="https://discord.gg/Zr5NJEQA"
              target="_blank"
              rel="noopener"
              ><img id="discord-widget" src="https://badgen.net/discord/online-members/Zr5NJEQA?color=7289DA&labelColor=1a1e23&icon=discord&label=Discord&scale=1.5" alt="Nano JSX Discord Server" title="Nano JSX Discord Server" /></a
            >
          </div>
        </div>
      </footer>
    </div>

    <!-- github corner -->
    <a href="https://github.com/nanojsx/nano" class="github-corner" aria-label="View source on GitHub">
      <svg
        width="80"
        height="80"
        viewBox="0 0 250 250"
        style="fill: #151513; color: #fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1)"
        aria-hidden="true"
      >
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
          d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
          fill="currentColor"
          style="transform-origin: 130px 106px"
          class="octo-arm"
        ></path>
        <path
          d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
          fill="currentColor"
          class="octo-body"
        ></path>
      </svg>
      <style>
        .github-corner:hover .octo-arm {
          animation: octocat-wave 560ms ease-in-out;
        }
        @keyframes octocat-wave {
          0%,
          100% {
            transform: rotate(0);
          }
          20%,
          60% {
            transform: rotate(-25deg);
          }
          40%,
          80% {
            transform: rotate(10deg);
          }
        }
        @media (max-width: 500px) {
          .github-corner:hover .octo-arm {
            animation: none;
          }
          .github-corner .octo-arm {
            animation: octocat-wave 560ms ease-in-out;
          }
        }
      </style>
    </a>

    <!-- prism scripts -->
    <link rel="stylesheet" href="/css/prism.css?ver=0.0.5" />
    <script src="/js/prism.js?ver=0.0.5"></script>
    <script src="/js/code-home.js"></script>
    <script>
      window.addEventListener('load', event => {
        for (const [key, value] of Object.entries(code)) {
          console.log(key)
          setTimeout(() => {
            document.getElementById(key).innerHTML = Prism.highlight(value, Prism.languages.tsx)
          }, 0)
        }
      })
    </script>

    <!-- codepen scripts (lazy load) -->
    <script>
      let observer = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            let script = document.createElement('script')
            script.src = 'https://static.codepen.io/assets/embed/ei.js'
            document.head.appendChild(script)

            observer.unobserve(entry.target)
          }
        })
      })
      observer.observe(document.getElementsByClassName('codepen-wrapper')[0])
    </script>

    <!-- github buttons -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>
  </body>
</html>
